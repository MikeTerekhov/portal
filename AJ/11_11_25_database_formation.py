# -*- coding: utf-8 -*-
"""11/11/25-database_formation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15ncCyE1p9YYMMw7MkylMWNdA1xzhFQrQ

Questions:


*   did you want ever subject matched (including injury and control)?
*   if so, do we need to download each subject file and combine through that?
*   why is map on new assesments different than the old one?
*   do we want to preserve all of the columns across the two tables? which ones should we discard?
*   When looking through the database, did you just want comparisons of both combined tables and their respective rows for each or are you looking for something else/more?

## Database on a per subject basis
"""

import pandas as pd
import numpy as np

NATALIE_SYMMETRY_CSV = "/Users/Mike/portal/300_natalie_symmetry_report_2025-10-20.csv"

META_CSV = "/Users/Mike/portal/AssessmentOfNeuromus_DATA_LABELS_2025-11-08_1518-1.csv"

def preprocessInjuried(csv1, csv2):
    # read files
    df_1 = pd.read_csv(csv1)      # symmetry report
    df_meta = pd.read_csv(csv2)   # assessment

    # filter df_1 for non-empty 'left_original_file_name'
    if 'left_original_file_name' in df_1.columns:
        df_1 = df_1[df_1['left_original_file_name'].notna() & (df_1['left_original_file_name'] != '')]
    else:
        print("Warning: 'left_original_file_name' not found in df_1. Skipping filter.")

    # strip col names
    df_1.columns = [c.strip() for c in df_1.columns]
    df_meta.columns = [c.strip() for c in df_meta.columns]

    # 1) find the participant-id column in meta
    meta_id_col = None
    for c in df_meta.columns:
        if c.startswith("Participant ID"):
            meta_id_col = c
            break
    if meta_id_col is None:
        raise KeyError("Could not find participant ID column in assessment CSV")

    # rename to subject_id so we can merge
    df_meta = df_meta.rename(columns={
        meta_id_col: "subject_id",
        "Dominant LEG": "dominant_leg",
    })
    # Participant Sex is already named like that

    # 2) create the columns your later code expects
    # consent
    if "Consent Performed" in df_meta.columns:
        df_meta["consent_acl"] = (df_meta["Consent Performed"] == "Yes").astype(int)
    else:
        df_meta["consent_acl"] = 0

    # reason
    if "Reason for ACL Test" in df_meta.columns:
        df_meta["reason_acl_test"] = df_meta["Reason for ACL Test"]
    else:
        df_meta["reason_acl_test"] = np.nan

    # injured leg: prefer "Injured Leg", fall back to "Confirm Injured Leg"
    injured_col = None
    if "Injured Leg" in df_meta.columns:
        injured_col = "Injured Leg"
    elif "Confirm Injured Leg" in df_meta.columns:
        injured_col = "Confirm Injured Leg"

    if injured_col:
        df_meta["injured_leg_acl"] = df_meta[injured_col].map({
            "Left": 1,
            "Right": 2
        })
    else:
        df_meta["injured_leg_acl"] = np.nan

    # 3) normalize IDs in BOTH
    df_meta["subject_id"] = (
        df_meta["subject_id"]
        .astype(str)
        .str.strip()
        .str.split("_").str[0]   # 01_222 -> 01
        .str.lstrip("0")         # 01 -> 1
    )

    df_1["subject_id"] = (
        df_1["subject_id"]
        .astype(str)
        .str.strip()
        .str.lstrip("0")
    )

    # 4) collapse meta to ONE ROW PER SUBJECT using first_not_null per column
    def first_not_null(s):
        s2 = s.dropna()
        return s2.iloc[0] if len(s2) > 0 else np.nan

    meta_per_subject = (
        df_meta
        .groupby("subject_id", as_index=False)
        .agg({col: first_not_null for col in df_meta.columns if col != "subject_id"})
    )

    # 5) merge with symmetry report
    merged_df = pd.merge(df_1, meta_per_subject, on="subject_id", how="left")

    # 6) keep only consented
    if "consent_acl" not in merged_df.columns:
        raise KeyError("'consent_acl' not found after merge.")
    df_injuried = merged_df[merged_df["consent_acl"] == 1]

    # 7) symmetry-validity filters
    df_injuried = df_injuried[
        (df_injuried["force_symmetry"].notna()) &
        (df_injuried["force_symmetry"] != 0)
    ]
    df_injuried = df_injuried[df_injuried["force_symmetry"] > -20]
    df_injuried = df_injuried[df_injuried["left_force"] != 0]
    df_injuried = df_injuried[df_injuried["right_force"] != 0]

    # 8) dominance_symmetry
    df_injuried["dominance_symmetry"] = np.where(
        df_injuried["dominant_leg"] == 1,
        np.where(
            df_injuried["right_force"] != 0,
            (df_injuried["right_force"] - df_injuried["left_force"]) / df_injuried["right_force"],
            np.nan,
        ),
        np.where(
            df_injuried["left_force"] != 0,
            (df_injuried["left_force"] - df_injuried["right_force"]) / df_injuried["left_force"],
            np.nan,
        ),
    )

    # 9) non-dominance symmetry
    df_injuried["nondominance_symmetry"] = np.where(
        df_injuried["dominant_leg"] == 1,
        np.where(
            df_injuried["left_force"] != 0,
            (df_injuried["left_force"] - df_injuried["right_force"]) / df_injuried["left_force"],
            np.nan,
        ),
        np.where(
            df_injuried["right_force"] != 0,
            (df_injuried["right_force"] - df_injuried["left_force"]) / df_injuried["right_force"],
            np.nan,
        ),
    )

    # 10) right / left symmetry
    df_injuried["right_symmetry"] = np.where(
        df_injuried["right_force"] != 0,
        (df_injuried["right_force"] - df_injuried["left_force"]) / df_injuried["right_force"],
        np.nan,
    )
    df_injuried["left_symmetry"] = np.where(
        df_injuried["right_force"] != 0,
        (df_injuried["left_force"] - df_injuried["right_force"]) / df_injuried["right_force"],
        np.nan,
    )

    # 11) injury_symmetry and injury_deficit
    if "injured_leg_acl" in df_injuried.columns:
        # (injured / noninjured) * 100
        df_injuried["injury_symmetry"] = np.where(
            df_injuried["injured_leg_acl"] == 1,  # left injured
            np.where(
                df_injuried["right_force"] != 0,
                (df_injuried["left_force"] / df_injuried["right_force"]) * 100,
                np.nan,
            ),
            # right injured
            np.where(
                df_injuried["left_force"] != 0,
                (df_injuried["right_force"] / df_injuried["left_force"]) * 100,
                np.nan,
            ),
        )

        # deficit = (injury - noninjury) / noninjury
        df_injuried["injury_deficit"] = np.where(
            df_injuried["injured_leg_acl"] == 1,  # left injured
            np.where(
                df_injuried["right_force"] != 0,
                (df_injuried["left_force"] - df_injuried["right_force"]) / df_injuried["right_force"],
                np.nan,
            ),
            # right injured
            np.where(
                df_injuried["left_force"] != 0,
                (df_injuried["right_force"] - df_injuried["left_force"]) / df_injuried["left_force"],
                np.nan,
            ),
        )
    else:
        df_injuried["injury_symmetry"] = np.nan
        df_injuried["injury_deficit"] = np.nan

    # 12) scale to percents for the ones that are ratios
    for col in ["dominance_symmetry", "right_symmetry", "nondominance_symmetry", "left_symmetry", "injury_deficit"]:
        df_injuried[col] = df_injuried[col] * 100

    return df_injuried

df_injury_filtered = preprocessInjuried(
    NATALIE_SYMMETRY_CSV,
    META_CSV
)

print(len(df_injury_filtered["injury_symmetry"]))
df_injury_filtered.to_csv("injury_filtered_data.csv", index=False)

"""## Database on a per event basis"""

import pandas as pd
import numpy as np

def _normalize_subject_id_redcap(s: pd.Series) -> pd.Series:
    # "01_500" -> "1"  (participant number only)
    s = s.astype(str).str.strip()
    return s.str.split("_", n=1).str[0].str.lstrip("0")

def _first_not_null(s: pd.Series):
    s2 = s.dropna()
    return s2.iloc[0] if len(s2) else np.nan

def homogenize_assessment_per_subject(df_meta: pd.DataFrame) -> pd.DataFrame:
    """Copy per-subject constants into all that subject's rows,
    EXCEPT: keep 'Event Name', 'Reason for ACL Test', and all *date*-like columns as they are."""
    # 1) find & rename the REDCap id
    meta_id_col = next((c for c in df_meta.columns if c.startswith("Participant ID")), None)
    if meta_id_col is None:
        raise KeyError("Participant ID column not found (starts with 'Participant ID').")
    df_meta = df_meta.rename(columns={meta_id_col: "subject_id"})
    df_meta["subject_id"] = _normalize_subject_id_redcap(df_meta["subject_id"])

    # 2) choose columns to NOT overwrite/copy
    fixed_exact = {"Event Name", "Reason for ACL Test"}
    fixed_date_like = {c for c in df_meta.columns if "date" in c.lower()}
    fixed_cols = fixed_exact | fixed_date_like | {"subject_id"}

    # 3) build per-subject template (first non-null) for all other columns
    fill_cols = [c for c in df_meta.columns if c not in fixed_cols]
    if not fill_cols:
        return df_meta

    tmpl = (df_meta.groupby("subject_id", as_index=False)[fill_cols]
                  .agg(_first_not_null)
                  .rename(columns={c: f"{c}__tmpl" for c in fill_cols}))

    # 4) merge back and fill only missing values in allowed columns
    out = df_meta.merge(tmpl, on="subject_id", how="left")
    for c in fill_cols:
        out[c] = out[c].fillna(out[f"{c}__tmpl"])
        out.drop(columns=[f"{c}__tmpl"], inplace=True)
    return out

def right_merge_on_subject(sym_csv: str, meta_csv: str) -> pd.DataFrame:
    df_sym  = pd.read_csv(sym_csv)
    df_meta = pd.read_csv(meta_csv)

    # symmetry: optional filter like your pipeline
    if "left_original_file_name" in df_sym.columns:
        df_sym = df_sym[df_sym["left_original_file_name"].astype(str).str.strip().ne("")]

    # strip columns
    df_sym.columns  = [c.strip() for c in df_sym.columns]
    df_meta.columns = [c.strip() for c in df_meta.columns]

    # homogenize meta per your rule
    df_meta = homogenize_assessment_per_subject(df_meta)

    # normalize symmetry subject_id
    if "subject_id" not in df_sym.columns:
        raise KeyError("Symmetry CSV must contain a 'subject_id' column.")
    df_sym["subject_id"] = df_sym["subject_id"].astype(str).str.strip().str.lstrip("0")

    # right-join on subject_id ONLY -> keeps all assessment rows (3mo/6mo/RTS, etc.)
    merged = pd.merge(
        df_sym,
        df_meta,
        on="subject_id",
        how="right",
        suffixes=("", "_meta"),
    )
    return merged

def add_symmetry_columns(df: pd.DataFrame) -> pd.DataFrame:
    df = df.copy()

    # --------- Harmonize dominant_leg (create numeric 1/2) ---------
    if "dominant_leg" not in df.columns:
        if "Dominant LEG" in df.columns:
            df["dominant_leg"] = df["Dominant LEG"]
        elif "Dominant Leg" in df.columns:
            df["dominant_leg"] = df["Dominant Leg"]
        else:
            df["dominant_leg"] = np.nan

    # Map strings -> numbers; keep numbers as-is; allow NaN
    if df["dominant_leg"].dtype == object:
        df["dominant_leg"] = (
            df["dominant_leg"].astype(str).str.strip().str.title()
              .map({"Right": 1, "Left": 2})
              .astype("float")
        )

    # --------- Build validity mask (assessment-only rows will stay NaN) ---------
    valid = (
        df.get("force_symmetry").notna() &
        (df["force_symmetry"] != 0) &
        (df["force_symmetry"] > -20) &
        (df.get("left_force")  != 0) &
        (df.get("right_force") != 0)
    ).fillna(False)

    # Precreate outputs
    for col in ["dominance_symmetry","nondominance_symmetry","right_symmetry",
                "left_symmetry","injury_symmetry","injury_deficit"]:
        if col not in df.columns:
            df[col] = np.nan

    # Masks for dominant side
    dom_right = valid & (df["dominant_leg"] == 1)
    dom_left  = valid & (df["dominant_leg"] == 2)

    # dominance_symmetry
    df.loc[dom_right, "dominance_symmetry"] = (
        (df.loc[dom_right, "right_force"] - df.loc[dom_right, "left_force"]) /
         df.loc[dom_right, "right_force"]
    )
    df.loc[dom_left, "dominance_symmetry"] = (
        (df.loc[dom_left, "left_force"] - df.loc[dom_left, "right_force"]) /
         df.loc[dom_left, "left_force"]
    )

    # nondominance_symmetry
    df.loc[dom_right, "nondominance_symmetry"] = (
        (df.loc[dom_right, "left_force"] - df.loc[dom_right, "right_force"]) /
         df.loc[dom_right, "left_force"]
    )
    df.loc[dom_left, "nondominance_symmetry"] = (
        (df.loc[dom_left, "right_force"] - df.loc[dom_left, "left_force"]) /
         df.loc[dom_left, "right_force"]
    )

    # right / left symmetry
    df.loc[valid, "right_symmetry"] = (
        (df.loc[valid, "right_force"] - df.loc[valid, "left_force"]) /
         df.loc[valid, "right_force"]
    )
    df.loc[valid, "left_symmetry"] = (
        (df.loc[valid, "left_force"] - df.loc[valid, "right_force"]) /
         df.loc[valid, "right_force"]
    )

    # injury_symmetry = (injured / noninjured) * 100
    has_inj = valid & df.get("injured_leg_acl").notna()
    left_inj  = has_inj & (df["injured_leg_acl"] == 1)
    right_inj = has_inj & (df["injured_leg_acl"] == 2)

    df.loc[left_inj,  "injury_symmetry"] = (df.loc[left_inj,  "left_force"]  / df.loc[left_inj,  "right_force"]) * 100
    df.loc[right_inj, "injury_symmetry"] = (df.loc[right_inj, "right_force"] / df.loc[right_inj, "left_force"])  * 100

    # injury_deficit = (injury - noninjury) / noninjury
    df.loc[left_inj,  "injury_deficit"] = (df.loc[left_inj,  "left_force"]  - df.loc[left_inj,  "right_force"]) / df.loc[left_inj,  "right_force"]
    df.loc[right_inj, "injury_deficit"] = (df.loc[right_inj, "right_force"] - df.loc[right_inj, "left_force"])  / df.loc[right_inj, "left_force"]

    # Scale ratio columns (not injury_symmetry, which is already %)
    for col in ["dominance_symmetry","nondominance_symmetry","right_symmetry","left_symmetry","injury_deficit"]:
        df[col] = df[col] * 100

    return df


def build_final_with_extra_columns(sym_csv: str, meta_csv: str) -> pd.DataFrame:
    merged = right_merge_on_subject(sym_csv, meta_csv)
    # Build/normalize the fields your math needs if they aren’t already present after homogenization:
    # consent (optional if you plan to filter by it)
    if "Consent Performed" in merged.columns and "consent_acl" not in merged.columns:
        merged["consent_acl"] = merged["Consent Performed"].astype(str).str.strip().str.lower().eq("yes").astype(int)
    # injured_leg_acl
    if "injured_leg_acl" not in merged.columns:
        inj_col = "Injured Leg" if "Injured Leg" in merged.columns else ("Confirm Injured Leg" if "Confirm Injured Leg" in merged.columns else None)
        merged["injured_leg_acl"] = merged[inj_col].map({"Left": 1, "Right": 2}) if inj_col else np.nan
    # dominant_leg numeric
    if "dominant_leg" in merged.columns and merged["dominant_leg"].dtype == object:
        merged["dominant_leg"] = merged["dominant_leg"].map({"Right": 1, "Left": 2})

    final = add_symmetry_columns(merged)

    # If you still want to drop rows without valid force data, you can filter here;
    # otherwise keep everything (assessment-only rows will have NaN metrics).
    return final

final = build_final_with_extra_columns(
    NATALIE_SYMMETRY_CSV,
    META_CSV
)

# If you want to *also* keep your earlier “consent + force validity” subset:
filtered = final[
    (final["consent_acl"] == 1) &
    final["force_symmetry"].notna() &
    (final["force_symmetry"] != 0) &
    (final["force_symmetry"] > -20) &
    (final["left_force"]  != 0) &
    (final["right_force"] != 0)
]

filtered.to_csv("merged_subject_rightjoin_with_metrics_FILTERED.csv", index=False)